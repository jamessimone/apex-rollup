// This script converts all DLRS rules (stored in dlrs__LookupRollupSummary2__mdt) to Rollup__mdt records and deploys them to the current org

// Use the org defaults for all converted rules
static final RollupControl__mdt ROLLUP_CONTROL = RollupControl__mdt.getInstance('Org_Defaults');

// Prepare the converted Rollup__mdt CMDT records for deployment
String customMetadataTypePrefix = Schema.Rollup__mdt.SObjectType.getDescribe().getName().replace('__mdt', '');
Metadata.DeployContainer deployment = new Metadata.DeployContainer();

List<String> objectsUnsupportedUsingEntityDefinition = new List<String>{ 'Event', 'Task', 'User' };
List<Map<String, String>> unmigrateableRules = new List<Map<String, String>>();
Boolean shouldDeploy = false;

for (dlrs__LookupRollupSummary2__mdt dlrsRule : dlrs__LookupRollupSummary2__mdt.getAll().values()) {
  if (dlrsRule.dlrs__Active__c == false) {
    // we won't migrate inactive rules
    continue;
  }

  Metadata.CustomMetadata customMetadata = new Metadata.CustomMetadata();
  customMetadata.fullName = customMetadataTypePrefix + '.' + dlrsRule.DeveloperName;
  customMetadata.label = dlrsRule.MasterLabel;

  String operation;
  switch on dlrsRule.dlrs__AggregateOperation__c {
    when 'Avg' {
      operation = 'AVERAGE';
    }
    when 'Concatenate' {
      operation = 'CONCAT';
    }
    when 'Concatenate Distinct' {
      operation = 'CONCAT_DISTINCT';
    }
    when 'Count Distinct' {
      operation = 'COUNT_DISTINCT';
    }
    when else {
      operation = dlrsRule.dlrs__AggregateOperation__c;
    }
  }

  Schema.SObjectField calcObject = Rollup__mdt.CalcItem__c;
  Schema.SObjectField lookupFieldCalcItem = Rollup__mdt.LookupFieldOnCalcItem__c;
  Schema.SObjectField lookupFieldParent = Rollup__mdt.LookupFieldOnLookupObject__c;
  Schema.SObjectField lookupObject = Rollup__mdt.LookupObject__c;
  Schema.SObjectField rollupFieldCalcItem = Rollup__mdt.RollupFieldOnCalcItem__c;
  Schema.SObjectField rollupFieldParent = Rollup__mdt.RollupFieldOnLookupObject__c;

  if (objectsUnsupportedUsingEntityDefinition.contains(dlrsRule.dlrs__ChildObject__c)) {
    calcObject = Rollup__mdt.CalcItemText__c;
    lookupFieldCalcItem = Rollup__mdt.LookupFieldOnCalcItemText__c;
    lookupFieldParent = Rollup__mdt.LookupFieldOnLookupObjectText__c;
    lookupObject = Rollup__mdt.LookupObjectText__c;
    rollupFieldCalcItem = Rollup__mdt.RollupFieldOnCalcItemText__c;
    rollupFieldParent = Rollup__mdt.RollupFieldOnLookupObjectText__c;
  } else {
    // This code uses instances of Metadata.CustomMetadataValue for the deployment - not instances of Rollup__mdt
    // So, use a map & field tokens to store the expected values - Salesforce will store the data as Rollup__mdt records when deployed
    Map<String, Object> fieldValuesToCopy = new Map<String, Object>{
      calcObject.getDescribe().getName() => dlrsRule.dlrs__ChildObject__c,
      Schema.Rollup__mdt.CalcItemWhereClause__c.getDescribe().getName() => dlrsRule.dlrs__RelationshipCriteria__c,
      Schema.Rollup__mdt.ConcatDelimiter__c.getDescribe().getName() => operation.startsWith('CONCAT') ? dlrsRule.dlrs__ConcatenateDelimiter__c : null,
      Schema.Rollup__mdt.Description__c.getDescribe().getName() => dlrsRule.dlrs__Description__c,
      Schema.Rollup__mdt.LimitAmount__c.getDescribe().getName() => dlrsRule.dlrs__RowLimit__c,
      lookupFieldCalcItem.getDescribe().getName() => dlrsRule.dlrs__RelationshipField__c,
      lookupFieldParent.getDescribe().getName() => 'Id',
      lookupObject.getDescribe().getName() => dlrsRule.dlrs__ParentObject__c,
      Schema.Rollup__mdt.OrderByFirstLast__c.getDescribe().getName() => dlrsRule.dlrs__FieldToOrderBy__c,
      Schema.Rollup__mdt.RollupControl__c.getDescribe().getName() => ROLLUP_CONTROL.DeveloperName,
      rollupFieldCalcItem.getDescribe().getName() => dlrsRule.dlrs__FieldToAggregate__c,
      rollupFieldParent.getDescribe().getName() => dlrsRule.dlrs__AggregateResultField__c,
      Schema.Rollup__mdt.RollupOperation__c.getDescribe().getName() => operation.toUpperCase(),
      Schema.Rollup__mdt.SharingMode__c.getDescribe().getName() => dlrsRule.dlrs__CalculationSharingMode__c

      // Additional DLRS fields that are not supported/used by Rollup
      // dlrs__AggregateAllRows__c
      // dlrs__CalculationMode__c
      // dlrs__RelationshipCriteriaFields__c
    };

    // Create the instance of Metadata.CustomMetadataValue for the current DLRS rule
    for (String fieldName : fieldValuesToCopy.keySet()) {
      Metadata.CustomMetadataValue customField = new Metadata.CustomMetadataValue();
      customField.field = fieldName;
      if (fieldName == Schema.Rollup__mdt.Description__c.getDescribe().getName()) {
        customField.value = 'Generated by migration script:\n' + fieldValuesToCopy.get(fieldName);
      } else {
        customField.value = fieldValuesToCopy.get(fieldName);
      }

      customMetadata.values.add(customField);
    }

    shouldDeploy = true;
    deployment.addMetadata(customMetadata);
  }
}

if (shouldDeploy) {
  // Deploy the converted Rollup__mdt CMDT records - these will be treated like an upsert based on DeveloperName
  System.debug(LoggingLevel.INFO, 'Deployment metadata:\n' + JSON.serialize(deployment));
  Id jobId = Metadata.Operations.enqueueDeployment(deployment, null);
  System.debug(LoggingLevel.INFO, 'Deployment Job ID: ' + jobId);
  System.debug(LoggingLevel.INFO, 'All DLRS rules were migrated to Rollup metadata successfully');
} else {
  System.debug(LoggingLevel.INFO, 'No DLRS rules to migrate, skipping metadata deploy');
}
