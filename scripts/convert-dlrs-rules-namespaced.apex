// This script converts all DLRS rules (stored in dlrs__LookupRollupSummary2__mdt) to please__Rollup__mdt records and deploys them to the current org

// Use the org defaults for all converted rules
static final please__RollupControl__mdt ROLLUP_CONTROL = please__RollupControl__mdt.getInstance('please__Org_Defaults');

// Prepare the converted Rollup__mdt CMDT records for deployment
String customMetadataTypePrefix = Schema.please__Rollup__mdt.SObjectType.toString().replace('__mdt', '');
Metadata.DeployContainer deployment = new Metadata.DeployContainer();

Set<String> objectsUnsupportedUsingEntityDefinition = new Set<String>{ Event.SObjectType.toString(), Task.SObjectType.toString(), User.SObjectType.toString() };
Boolean shouldDeploy = false;

for (dlrs__LookupRollupSummary2__mdt dlrsRule : dlrs__LookupRollupSummary2__mdt.getAll().values()) {
  if (dlrsRule.dlrs__Active__c == false) {
    // we won't migrate inactive rules
    continue;
  }

  Metadata.CustomMetadata customMetadata = new Metadata.CustomMetadata();
  customMetadata.fullName = customMetadataTypePrefix + '.' + dlrsRule.DeveloperName;
  customMetadata.label = dlrsRule.MasterLabel;

  String operation;
  switch on dlrsRule.dlrs__AggregateOperation__c {
    when 'Avg' {
      operation = 'AVERAGE';
    }
    when 'Concatenate' {
      operation = 'CONCAT';
    }
    when 'Concatenate Distinct' {
      operation = 'CONCAT_DISTINCT';
    }
    when 'Count Distinct' {
      operation = 'COUNT_DISTINCT';
    }
    when else {
      operation = dlrsRule.dlrs__AggregateOperation__c;
    }
  }

  Schema.SObjectField calcObject = please__Rollup__mdt.please__CalcItem__c;
  Schema.SObjectField lookupFieldCalcItem = please__Rollup__mdt.please__LookupFieldOnCalcItem__c;
  Schema.SObjectField lookupFieldParent = please__Rollup__mdt.please__LookupFieldOnLookupObject__c;
  Schema.SObjectField lookupObject = please__Rollup__mdt.please__LookupObject__c;
  Schema.SObjectField rollupFieldCalcItem = please__Rollup__mdt.please__RollupFieldOnCalcItem__c;
  Schema.SObjectField rollupFieldParent = please__Rollup__mdt.please__RollupFieldOnLookupObject__c;

  if (objectsUnsupportedUsingEntityDefinition.contains(dlrsRule.dlrs__ChildObject__c)) {
    calcObject = please__Rollup__mdt.please__CalcItemText__c;
    lookupFieldCalcItem = please__Rollup__mdt.please__LookupFieldOnCalcItemText__c;
    lookupFieldParent = please__Rollup__mdt.please__LookupFieldOnLookupObjectText__c;
    lookupObject = please__Rollup__mdt.please__LookupObjectText__c;
    rollupFieldCalcItem = please__Rollup__mdt.please__RollupFieldOnCalcItemText__c;
    rollupFieldParent = please__Rollup__mdt.please__RollupFieldOnLookupObjectText__c;
  }
  if (dlrsRule.dlrs__ConcatenateDelimiter__c?.equalsIgnoreCase('BR()') == true) {
    dlrsRule.dlrs__ConcatenateDelimiter__c = '\n';
  }

  // This code uses instances of Metadata.CustomMetadataValue for the deployment - not instances of Rollup__mdt
  // So, use a map & field tokens to store the expected values - Salesforce will store the data as Rollup__mdt records when deployed
  Map<String, Object> fieldValuesToCopy = new Map<String, Object>{
    calcObject.toString() => dlrsRule.dlrs__ChildObject__c,
    please__Rollup__mdt.please__CalcItemWhereClause__c.toString() => dlrsRule.dlrs__RelationshipCriteria__c,
    please__Rollup__mdt.please__ConcatDelimiter__c.toString() => operation.startsWith('CONCAT') ? dlrsRule.dlrs__ConcatenateDelimiter__c : null,
    please__Rollup__mdt.please__Description__c.toString() => dlrsRule.dlrs__Description__c,
    please__Rollup__mdt.please__LimitAmount__c.toString() => dlrsRule.dlrs__RowLimit__c,
    lookupFieldCalcItem.toString() => dlrsRule.dlrs__RelationshipField__c,
    lookupFieldParent.toString() => 'Id',
    lookupObject.toString() => dlrsRule.dlrs__ParentObject__c,
    please__Rollup__mdt.please__OrderByFirstLast__c.toString() => dlrsRule.dlrs__FieldToOrderBy__c,
    please__Rollup__mdt.please__RollupControl__c.toString() => ROLLUP_CONTROL.DeveloperName,
    rollupFieldCalcItem.toString() => dlrsRule.dlrs__FieldToAggregate__c,
    rollupFieldParent.toString() => dlrsRule.dlrs__AggregateResultField__c,
    please__Rollup__mdt.please__RollupOperation__c.toString() => operation.toUpperCase(),
    please__Rollup__mdt.please__SharingMode__c.toString() => dlrsRule.dlrs__CalculationSharingMode__c

    // Additional DLRS fields that are not supported/used by Rollup
    // dlrs__AggregateAllRows__c
    // dlrs__CalculationMode__c
    // dlrs__RelationshipCriteriaFields__c
  };

  // Create the instance of Metadata.CustomMetadataValue for the current DLRS rule
  for (String fieldName : fieldValuesToCopy.keySet()) {
    Metadata.CustomMetadataValue customField = new Metadata.CustomMetadataValue();
    customField.field = fieldName;
    if (fieldName == please__Rollup__mdt.please__Description__c.toString()) {
      customField.value = 'Generated by migration script:\n' + fieldValuesToCopy.get(fieldName);
    } else {
      customField.value = fieldValuesToCopy.get(fieldName);
    }

    customMetadata.values.add(customField);
  }

  shouldDeploy = true;
  deployment.addMetadata(customMetadata);
}

if (shouldDeploy) {
  // Deploy the converted Rollup__mdt CMDT records - these will be treated like an upsert based on DeveloperName
  System.debug(LoggingLevel.INFO, 'Deployment metadata:\n' + JSON.serialize(deployment));
  Id jobId = Metadata.Operations.enqueueDeployment(deployment, null);
  System.debug(LoggingLevel.INFO, 'Deployment Job ID: ' + jobId);
  System.debug(LoggingLevel.INFO, 'All DLRS rules were migrated to Rollup metadata successfully');
} else {
  System.debug(LoggingLevel.INFO, 'No DLRS rules to migrate, skipping metadata deploy');
}
