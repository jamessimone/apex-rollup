public without sharing abstract class RollupCalculator {
  private Boolean isCDCUpdate = false;
  private Boolean isFirstTimeThrough = true;
  private Boolean isMultiCurrencyRollup = false;
  private Boolean isRecursiveRecalc = false;
  private Boolean isFullRecalc = false;

  protected final SObjectField opFieldOnCalcItem;
  protected final SObjectField opFieldOnLookupObject;
  protected final SObjectField lookupKeyField;
  protected final Rollup.Op op;
  protected final Rollup__mdt metadata;
  protected final String lookupKeyQuery;
  protected final String lookupRecordKey;
  protected final Boolean isChangedFieldCalc;

  protected Rollup.Evaluator eval;
  protected Boolean shouldShortCircuit = false;
  protected Object returnVal;
  protected Boolean isLastItem = false;
  protected Boolean shouldTriggerFullRecalc;
  protected String parentIsoCode;

  @TestVisible
  private static Factory testFactory;

  public static Factory Factory {
    get {
      if (Factory == null) {
        Factory = testFactory == null ? new RollupCalculator.Factory() : testFactory;
      }
      return Factory;
    }
    set;
  }

  public virtual class Factory {
    public virtual RollupCalculator getCalculator(
      Object priorVal,
      Rollup.Op op,
      SObjectfield opFieldOnCalcItem,
      SObjectField opFieldOnLookupObject,
      Rollup__mdt metadata,
      String lookupRecordKey,
      SObjectField lookupKeyField
    ) {
      RollupCalculator calc;
      if (op.name().contains(Rollup.Op.COUNT_DISTINCT.name())) {
        calc = new CountDistinctRollupCalculator(priorVal, op, opFieldOnCalcItem, opFieldOnLookupObject, metadata, lookupRecordKey, lookupKeyField);
      } else if (op.name().contains(Rollup.Op.COUNT.name())) {
        calc = new CountRollupCalculator(priorVal, op, opFieldOnCalcItem, opFieldOnLookupObject, metadata, lookupRecordKey, lookupKeyField);
      } else if (op.name().contains(Rollup.Op.AVERAGE.name())) {
        calc = new AverageRollupCalculator(priorVal, op, opFieldOnCalcItem, opFieldOnLookupObject, metadata, lookupRecordKey, lookupKeyField);
      } else if (op.name().contains(Rollup.Op.FIRST.name()) || op.name().contains(Rollup.Op.LAST.name())) {
        calc = new FirstLastRollupCalculator(priorVal, op, opFieldOnCalcItem, opFieldOnLookupObject, metadata, lookupRecordKey, lookupKeyField);
      } else if (priorVal instanceof Decimal) {
        calc = new DecimalRollupCalculator(priorVal, op, opFieldOnCalcItem, opFieldOnLookupObject, metadata, lookupRecordKey, lookupKeyField);
      } else if (priorVal instanceof String) {
        calc = new PicklistRollupCalculator(
          priorVal,
          op,
          opFieldOnCalcItem,
          opFieldOnLookupObject,
          metadata,
          lookupRecordKey,
          lookupKeyField,
          metadata.ConcatDelimiter__c
        );
      } else if (priorVal instanceof Date) {
        // not obvious: the order of these else if's is of supreme importance
        // Date has to go before Datetime; in the same way that all numbers test true as an instanceof Decimal
        // all Dates test true as Datetimes ...
        calc = new DateRollupCalculator(priorVal, op, opFieldOnCalcItem, opFieldOnLookupObject, metadata, lookupRecordKey, lookupKeyField);
      } else if (priorVal instanceof Time) {
        calc = new TimeRollupCalculator(priorVal, op, opFieldOnCalcItem, opFieldOnLookupObject, metadata, lookupRecordKey, lookupKeyField);
      } else if (priorval instanceof Datetime) {
        calc = new DatetimeRollupCalculator(priorVal, op, opFieldOnCalcItem, opFieldOnLookupObject, metadata, lookupRecordKey, lookupKeyField);
      } else {
        throw new IllegalArgumentException('Calculation not defined for: ' + JSON.serialize(priorVal));
      }
      return calc;
    }
  }

  protected RollupCalculator(
    Object priorVal,
    Rollup.Op op,
    SObjectField opFieldOnCalcItem,
    SObjectField opFieldOnLookupObject,
    Object defaultVal,
    Rollup__mdt metadata,
    String lookupRecordKey,
    SObjectField lookupKeyField
  ) {
    this.opFieldOnLookupObject = opFieldOnLookupObject;
    this.opFieldOnCalcItem = opFieldOnCalcItem;
    this.lookupRecordKey = lookupRecordKey;
    this.lookupKeyField = lookupKeyField;
    this.op = op;
    this.metadata = metadata;

    if (defaultVal != null) {
      this.returnVal = defaultVal;
    } else {
      this.returnVal = priorVal == null ? RollupFieldInitializer.Current.getDefaultValue(opFieldOnLookupObject) : priorVal;
    }
    this.lookupKeyQuery =
      lookupKeyField +
      ' = \'' +
      lookupRecordKey +
      '\'' +
      (String.isBlank(metadata.CalcItemWhereClause__c) ? '' : ' AND (' + metadata.CalcItemWhereClause__c + ')');
    this.isMultiCurrencyRollup =
      UserInfo.isMultiCurrencyOrganization() &&
      (this.opFieldOnCalcItem?.getDescribe().getType() == DisplayType.CURRENCY ||
      this.opFieldOnLookupObject?.getDescribe().getType() == DisplayType.CURRENCY);
    this.isChangedFieldCalc = String.isNotBlank(this.metadata.ChangedFieldsOnCalcItem__c);
  }
  public virtual Object getReturnValue() {
    return this.returnVal;
  }

  public void setCDCUpdate(Boolean isCDCUpdate) {
    this.isCDCUpdate = isCDCUpdate;
  }

  public void setEvaluator(Rollup.Evaluator eval) {
    this.eval = eval;
  }

  public void setFullRecalc(Boolean isFullRecalc) {
    this.isFullRecalc = isFullRecalc;
  }

  public void setMultiCurrencyInfo(SObject parentRecord) {
    if (parentRecord.getPopulatedFieldsAsMap().containsKey(RollupCurrencyInfo.CURRENCY_ISO_CODE_FIELD_NAME)) {
      this.parentIsoCode = (String) parentRecord.get(RollupCurrencyInfo.CURRENCY_ISO_CODE_FIELD_NAME);
    }
  }

  public virtual void performRollup(List<SObject> calcItems, Map<Id, SObject> oldCalcItems) {
    // if we're already in a full recalc, we've got all the items we need already
    this.shouldTriggerFullRecalc = this.isFullRecalc == false;
    List<Id> exclusionIds = new List<Id>();
    for (SObject calcItem : calcItems) {
      if (calcItem.Id != null) {
        exclusionIds.add(calcItem.Id);
      }
    }
    List<SObject> localCalcItems = this.winnowItems(calcItems, oldCalcItems);

    for (Integer index = 0; index < localCalcItems.size(); index++) {
      this.isLastItem = index == localCalcItems.size() - 1;
      SObject calcItem = localCalcItems[index];
      Boolean doesNotMatch = this.eval?.matches(calcItem) == false;
      if (doesNotMatch && oldCalcItems.containsKey(calcItem.Id)) {
        doesNotMatch = doesNotMatch && this.eval?.matches(oldCalcItems.get(calcItem.Id)) == false;
      }

      // it's only a full recalc situation if there are no items left after winnowing
      // otherwise, for even one item in the list, this should cause "shouldTriggerFullRecalc" to evaluate to false
      if (this.shouldTriggerFullRecalc) {
        this.shouldTriggerFullRecalc = doesNotMatch;
      }

      if (this.shouldShortCircuit) {
        this.handleShortCircuit(calcItem);
        continue;
      } else if (this.isCDCUpdate) {
        // here we don't exclude items because the calc items have already been updated
        this.returnVal = this.calculateNewAggregateValue(this.op, new List<Id>(), calcItem.getSObjectType());
        // not just a break, a return. We don't want to pass go - we don't want to call "setReturnValue" below
        return;
      } else {
        switch on op {
          when COUNT_DISTINCT, DELETE_COUNT_DISTINCT {
            this.handleCountDistinct(calcItem);
          }
          when UPDATE_COUNT_DISTINCT {
            this.handleUpdateCountDistinct(calcItem);
          }
          when SUM, COUNT {
            this.handleSumOrCount(calcItem);
          }
          when UPDATE_SUM, UPDATE_COUNT {
            this.handleUpdateSumOrCount(calcItem, oldCalcItems);
          }
          when DELETE_SUM, DELETE_COUNT {
            this.handleDeleteSumOrCount(calcItem);
          }
          when MIN {
            this.handleMin(calcItem);
          }
          when MAX {
            this.handleMax(calcItem);
          }
          when UPDATE_MAX, UPDATE_MIN, DELETE_MAX, DELETE_MIN {
            this.handleUpdateMinOrMax(calcItem, oldCalcItems);
          }
          when CONCAT, CONCAT_DISTINCT {
            this.handleConcat(calcItem);
          }
          when UPDATE_CONCAT, UPDATE_CONCAT_DISTINCT {
            this.handleUpdateConcat(calcItem, oldCalcItems);
          }
          when DELETE_CONCAT, DELETE_CONCAT_DISTINCT {
            this.handleDeleteConcat(calcItem);
          }
        }
      }

      if (this.shouldShortCircuit && this.isFirstTimeThrough) {
        /**
         * an example of short circuiting - halfway through the list during a MIN operation,
         * Rollup encounters a calcItem whose previous value equals the current min, but the new value
         * is greater than the min. This triggers a full recalc, since it is at once both possible
         * for items outside the list of calcItems to contain the new min, as WELL as for an item
         * WITHIN the existing calcItems to be the new min. This means we have to go back and re-process
         * the records that were already iterated on to ensure that the current operation successfully accounts
         * for everything in-memory and in the database
         */
        this.isFirstTimeThrough = false;
        if (index != 0 && calcItems.size() > 1) {
          index = 0; // resets the for-loop
        }
      }
    }
    // if there were no matching items, it's time for a full recalc
    // AVERAGE and FIRST/LAST *also* handle this operation, but they override the entirety of the method we're in
    // ("performRollup"); this means String, Number, and Datetime variant rollup calculations all need to correctly handle
    // recalculating via "calculateNewAggregateValue"
    if (this.shouldTriggerFullRecalc) {
      this.returnVal = this.calculateNewAggregateValue(this.op, exclusionIds, this.getCalcItemType());
      // bail on calling setReturnValue below
      return;
    }
    this.setReturnValue();
  }

  // all of these are no-ops by default; child classes opt-in to the rollup types applicable
  public virtual void handleCountDistinct(SObject calcItem) {
  }
  public virtual void handleUpdateCountDistinct(SObject calcItem) {
  }
  public virtual void handleSumOrCount(SObject calcItem) {
  }
  public virtual void handleUpdateSumOrCount(SObject calcItem, Map<Id, SObject> oldCalcItems) {
  }
  public virtual void handleDeleteSumOrCount(SObject calcItem) {
  }
  public virtual void handleMin(SObject calcItem) {
  }
  public virtual void handleMax(SObject calcItem) {
  }
  public virtual void handleUpdateMinOrMax(SObject calcItem, Map<Id, SObject> oldCalcItems) {
  }
  public virtual void handleConcat(SObject calcItem) {
  }
  public virtual void handleUpdateConcat(SObject calcItem, Map<Id, SObject> oldCalcItems) {
  }
  public virtual void handleDeleteConcat(SObject calcItem) {
  }
  protected virtual void handleShortCircuit(SObject calcItem) {
  }
  protected virtual void setReturnValue() {
  }

  protected List<SObject> winnowItems(List<SObject> items, Map<Id, SObject> oldCalcItems) {
    List<SObject> temporaryItems = new List<SObject>(items);
    items.clear(); // the List may not be strongly typed, but this is a good way to keep it typed if it is
    for (SObject item : temporaryItems) {
      Boolean currentItemMatches = this.eval?.matches(item) != false;
      if (currentItemMatches) {
        this.transformForMultiCurrencyOrgs(item);
        items.add(this.getTransformedCalcItem(item));
      } else if (
        (this.op == Rollup.Op.UPDATE_COUNT ||
        this.op == Rollup.Op.UPDATE_CONCAT_DISTINCT ||
        this.op == Rollup.Op.UPDATE_CONCAT ||
        this.op == Rollup.Op.UPDATE_SUM) &&
        this.isChangedFieldCalc == false &&
        currentItemMatches == false &&
        oldCalcItems.containsKey(item.Id) &&
        this.eval?.matches(oldCalcItems.get(item.Id)) == true
      ) {
        this.transformForMultiCurrencyOrgs(item);
        items.add(this.getTransformedCalcItem(item));
      }
    }

    return items;
  }

  protected SObjectType getCalcItemType() {
    return RollupFieldInitializer.Current.getSObjectFromName(this.metadata.CalcItem__c).getSObjectType();
  }

  protected virtual Object calculateNewAggregateValue(Rollup.Op op, List<Object> objIds, SObjectType sObjectType) {
    String operationName = Rollup.getBaseOperationName(op.name());
    String alias = operationName.toLowerCase() + 'Field';
    List<SObject> aggregate = this.tryQuery(sObjectType, new Set<String>{ operationName + '(' + this.opFieldOnCalcItem + ')' + alias }, objIds);
    return aggregate.isEmpty() == false ? aggregate[0].get(alias) : null;
  }

  protected Boolean isReparented(SObject calcItem, SObject oldCalcItem) {
    return calcItem?.get(this.lookupKeyField) != oldCalcItem?.get(this.lookupKeyField);
  }

  protected SObject getTransformedCalcItem(SObject calcItem) {
    return RollupCurrencyInfo.getCalcItem(calcItem);
  }

  protected Object performBaseCalculation(Rollup.Op op, List<Object> objIds, SObjectType sObjectType) {
    this.returnVal = RollupFieldInitializer.Current.getDefaultValue(this.opFieldOnLookupObject);

    if (this.isRecursiveRecalc == false) {
      this.isRecursiveRecalc = true; // now we're cooking with gas
      Set<String> queryFields = new Set<String>{ this.metadata.LookupFieldOnCalcItem__c, String.valueOf(this.opFieldOnCalcItem) };
      if (String.isNotBlank(this.metadata.CalcItemWhereClause__c)) {
        queryFields.addAll(RollupEvaluator.getWhereEval(this.metadata.CalcItemWhereClause__c, sObjectType).getQueryFields());
      }

      List<SObject> allOtherItems = this.tryQuery(sObjectType, queryFields, objIds);
      if (allOtherItems.isEmpty()) {
        // break out of recursion if there's nothing to calculate
        this.returnVal = null;
      } else {
        Rollup.Op baseOp = Rollup.Op.valueOf(Rollup.getBaseOperationName(op.name()));
        RollupCalculator calc = Factory.getCalculator(
          this.returnVal,
          baseOp,
          this.opFieldOnCalcItem,
          this.opFieldOnLookupObject,
          this.metadata,
          this.lookupRecordKey,
          this.lookupKeyField
        );
        calc.parentIsoCode = this.parentIsoCode;
        calc.performRollup(allOtherItems, new Map<Id, SObject>());
        this.returnVal = calc.getReturnValue();
      }
    }
    return this.returnVal;
  }

  private List<SObject> tryQuery(SObjectType sObjectType, Set<String> queryFields, List<Object> objIds) {
    String query = RollupQueryBuilder.Current.getQuery(sObjectType, new List<String>(queryFields), 'Id', '!=', this.lookupKeyQuery);
    List<SObject> results;
    try {
      results = Database.query(query);
    } catch (System.QueryException qex) {
      query = RollupQueryBuilder.Current.getQuery(sObjectType, new List<String>(queryFields), 'Id', '!=');
      results = Database.query(query);
    }
    return results;
  }

  private void transformForMultiCurrencyOrgs(SObject calcItem) {
    if (this.isMultiCurrencyRollup) {
      RollupCurrencyInfo.transformForMultiCurrencyOrgs(calcItem, this.opFieldOnCalcItem, this.parentIsoCode, this.metadata.OrderByFirstLast__c);
    }
  }

  private inherited sharing class CountDistinctRollupCalculator extends RollupCalculator {
    private final Set<Object> distinctValues;
    private final Boolean isIdCount;
    public CountDistinctRollupCalculator(
      Object priorVal,
      Rollup.Op op,
      SObjectfield opFieldOnCalcItem,
      SObjectField opFieldOnLookupObject,
      Rollup__mdt metadata,
      String lookupRecordKey,
      SObjectField lookupKeyField
    ) {
      super(priorVal, op, opFieldOnCalcItem, opFieldOnLookupObject, metadata.FullRecalculationDefaultNumberValue__c, metadata, lookupRecordKey, lookupKeyField);
      this.distinctValues = new Set<Object>();
      this.isIdCount = this.opFieldOnCalcItem.getDescribe().getName() == 'Id';
      Object defaultVal = RollupFieldInitializer.Current.getDefaultValue(opFieldOnLookupObject);
      if (defaultVal != 0 && this.returnVal != defaultVal && this.isIdCount == false) {
        this.distinctValues.add(this.returnVal);
      }
    }

    protected override void setReturnValue() {
      this.returnVal = Decimal.valueOf(this.distinctValues.size());
    }

    protected override void handleShortCircuit(SObject calcItem) {
      Object currentVal = calcItem.get(this.opFieldOnCalcItem);
      if (currentVal != null && this.op != Rollup.Op.DELETE_COUNT_DISTINCT) {
        this.distinctValues.add(currentVal);
      }
    }

    public override void handleCountDistinct(SObject calcItem) {
      Object potentiallyNullValue = calcItem.get(this.opFieldOnCalcItem);
      if (this.op != Rollup.Op.DELETE_COUNT_DISTINCT && potentiallyNullValue != null) {
        this.distinctValues.add(potentiallyNullValue);
      } else if (this.op == Rollup.Op.DELETE_COUNT_DISTINCT) {
        this.distinctValues.clear();
        this.calculateNewAggregateValue(this.op, new List<Id>{ calcItem.Id }, calcItem.getSObjectType());
      }
      this.shouldShortCircuit = true;
    }

    public override void handleUpdateCountDistinct(SObject calcItem) {
      this.shouldShortCircuit = true;
      this.handleShortCircuit(calcItem);
    }

    @SuppressWarnings('PMD.ApexSOQLInjection')
    protected override Object calculateNewAggregateValue(Rollup.Op op, List<Object> objIds, SObjectType sObjectType) {
      if (this.shouldTriggerFullRecalc == true) {
        this.distinctValues.clear();
      }
      Boolean isArchivable = sObjectType == Task.SObjectType || sObjectType == Event.SObjectType;
      Boolean isGroupable = isArchivable == false && this.opFieldOnCalcItem.getDescribe().isGroupable();
      List<String> queryFields = new List<String>{ String.valueOf(this.opFieldOnCalcItem) };
      String calcItemOpField = this.opFieldOnCalcItem.getDescribe().getName();
      if (isGroupable) {
        queryFields.add(this.isIdCount ? 'COUNT()' : 'COUNT(Id)');
      }

      String query =
        RollupQueryBuilder.Current.getQuery(sObjectType, queryFields, 'Id', '!=', this.lookupKeyQuery + ('\nAND ' + this.opFieldOnCalcItem + '!= null')) +
        (isGroupable && this.isIdCount == false ? ('\nGROUP BY ' + this.opFieldOnCalcItem) : '');

      if (this.isIdCount) {
        Integer result = Database.countQuery(query.replaceAll('(?<=(\\s|,))Id,', ''));
        for (Integer index = 0; index < result; index++) {
          this.distinctValues.add(index);
        }
      } else {
        List<SObject> results = Database.query(query);
        for (SObject res : results) {
          // have to use the String representation of the this.opFieldOnCalcItem to avoid:
          // System.SObjectException: SObject.FieldName does not belong to SObject type AggregateResult
          this.distinctValues.add(res.get(calcItemOpField));
        }
      }
      // OK to return an int here; setReturnValue does the needful type conversion
      // from Integer -> Decimal to avoid potential BigDecimal sorting issues downstream
      return this.distinctValues.size();
    }
  }

  private inherited sharing virtual class DecimalRollupCalculator extends RollupCalculator {
    private Decimal returnDecimal;
    public DecimalRollupCalculator(
      Object priorVal,
      Rollup.Op op,
      SObjectField opFieldOnCalcItem,
      SObjectField opFieldOnLookupObject,
      Rollup__mdt metadata,
      String lookupRecordKey,
      SObjectField lookupKeyField
    ) {
      super(priorVal, op, opFieldOnCalcItem, opFieldOnLookupObject, metadata.FullRecalculationDefaultNumberValue__c, metadata, lookupRecordKey, lookupKeyField);
      this.returnDecimal = (Decimal) this.returnVal;
    }

    protected virtual Decimal getDecimalOrDefault(Object potentiallyUnitializedDecimal) {
      if (potentiallyUnitializedDecimal instanceof Decimal) {
        return (Decimal) potentiallyUnitializedDecimal;
      } else {
        return Decimal.valueOf(potentiallyUnitializedDecimal == null ? 0 : 1);
      }
    }

    protected virtual Decimal getNumericValue(SObject calcItem) {
      return this.getDecimalOrDefault(calcItem.get(this.opFieldOnCalcItem));
    }

    protected virtual Decimal getNumericChangedValue(SObject calcItem, Map<Id, SObject> oldCalcItems) {
      SObject oldCalcItem = oldCalcItems.get(calcItem.Id);

      Decimal newVal = this.getNumericValue(calcItem);
      Decimal oldVal = oldCalcItem != null ? this.getNumericValue(oldCalcItem) : newVal;

      Boolean matchesCurrent = this.eval?.matches(calcItem) == true;
      Boolean matchesOld = oldCalcItem != null && this.eval?.matches(oldCalcItem) == true;

      if (this.isReparented(calcItem, oldCalcItem)) {
        return newVal;
      } else if (matchesCurrent && matchesOld == false && this.isChangedFieldCalc == false) {
        return newVal;
      } else if (matchesCurrent == false && matchesOld && this.isChangedFieldCalc == false) {
        return oldVal * Decimal.valueOf(-1).setScale(oldVal.scale());
      }

      // could be negative, could be positive ... could be 0!
      return newVal - oldVal;
    }

    public virtual override Object getReturnValue() {
      if (this.returnVal == RollupFieldInitializer.Current.maximumLongValue || this.returnVal == RollupFieldInitializer.Current.minimumLongValue) {
        this.returnVal = 0.00;
      }
      return this.returnVal;
    }

    protected override void handleShortCircuit(SObject calcItem) {
      switch on this.op {
        when UPDATE_MAX {
          // re-maxing by way of query has occurred, but is it **correct**?
          // if one of the other updated calcItems is numerically superior, assign the new max
          Decimal newVal = this.getNumericValue(calcItem);
          if (newVal > returnDecimal) {
            this.returnDecimal = newVal;
          }
        }
        when UPDATE_MIN {
          // re-"min"-ing has occurred by way of query, but is an in-memory calcItem even less?
          Decimal newVal = this.getNumericValue(calcItem);
          if (newVal < returnDecimal) {
            this.returnDecimal = newVal;
          }
        }
      }
    }

    public override void handleSumOrCount(SObject calcItem) {
      this.returnDecimal += this.getNumericValue(calcItem);
    }

    public override void handleUpdateSumOrCount(SObject calcItem, Map<Id, SObject> oldCalcItems) {
      this.returnDecimal += this.getNumericChangedValue(calcItem, oldCalcItems);
    }

    public override void handleDeleteSumOrCount(SObject calcItem) {
      this.returnDecimal -= this.getNumericValue(calcItem);
    }

    public override void handleMax(SObject calcItem) {
      Decimal numericValue = this.getNumericValue(calcItem);
      if (numericValue > this.returnDecimal || this.returnDecimal == 0) {
        this.returnDecimal = numericValue;
      }
    }

    public override void handleMin(SObject calcItem) {
      Decimal numericValue = this.getNumericValue(calcItem);
      if (numericValue < this.returnDecimal || this.returnDecimal == 0) {
        this.returnDecimal = numericValue;
      }
    }

    public override void handleUpdateMinOrMax(SObject calcItem, Map<Id, SObject> oldCalcItems) {
      Decimal newVal = this.getNumericValue(calcItem);
      Decimal thisPriorVal = this.getNumericValue((oldCalcItems.containsKey(calcItem.Id) ? oldCalcItems.get(calcItem.Id) : calcItem));
      if (
        (this.op.name().contains(Rollup.Op.MAX.name()) && thisPriorVal != 0 && thisPriorVal == this.returnDecimal && newVal <= thisPriorVal) ||
        (this.op.name().contains(Rollup.Op.MIN.name()) &&
        thisPriorVal != 0 &&
        thisPriorVal == this.returnDecimal &&
        newVal >= thisPriorVal)
      ) {
        this.shouldShortCircuit = true;
        Object potentialReturnValue = this.calculateNewAggregateValue(this.op, oldCalcItems.values(), calcItem.getSObjectType());
        this.returnDecimal = this.getDecimalOrDefault(potentialReturnValue);
        if (this.returnDecimal == 0 && this.op.name().contains('DELETE') == false) {
          this.returnDecimal = newVal;
        }
      } else if (this.op == Rollup.Op.UPDATE_MAX && newVal > this.returnDecimal) {
        this.returnDecimal = newVal;
      } else if (this.op == Rollup.Op.UPDATE_MIN && newVal < this.returnDecimal || this.returnDecimal == 0) {
        this.returnDecimal = newVal;
      }
    }

    protected override void setReturnValue() {
      this.returnVal = this.returnDecimal;
    }

    protected virtual override Object calculateNewAggregateValue(Rollup.Op op, List<Object> objIds, SObjectType sObjectType) {
      Object aggregate;
      try {
        aggregate = super.calculateNewAggregateValue(op, objIds, sObjectType);
      } catch (Exception ex) {
        aggregate = this.performBaseCalculation(op, objIds, sObjectType);
      }
      // for count-based rollups, fine to use 0 in the event of no matches
      // but otherwise, it's more accurate to be nulling out the parent fields if there isn't a max, for example
      if (aggregate == 0 && op.name().contains('COUNT') == false) {
        aggregate = null;
      }
      return aggregate;
    }
  }

  private inherited sharing virtual class DatetimeRollupCalculator extends DecimalRollupCalculator {
    public DatetimeRollupCalculator(
      Object priorVal,
      Rollup.Op op,
      SObjectfield opFieldOnCalcItem,
      SObjectField opFieldOnLookupObject,
      Rollup__mdt metadata,
      String lookupRecordKey,
      SObjectField lookupKeyField
    ) {
      super(((Datetime) priorVal).getTime(), op, opFieldOnCalcItem, opFieldOnLookupObject, metadata, lookupRecordKey, lookupKeyField);
    }

    public virtual override Object getReturnValue() {
      Object superReturnVal = super.getReturnValue();
      if (superReturnVal instanceof Decimal && superReturnVal != 0) {
        superReturnVal = Datetime.newInstance(((Decimal) superReturnVal).longValue());
      }
      return superReturnVal;
    }

    protected virtual override Decimal getDecimalOrDefault(Object potentiallyUnitializedDecimal) {
      if (potentiallyUnitializedDecimal == null) {
        return RollupFieldInitializer.Current.defaultDateTime.getTime();
      }
      // one of the worst things about SOQL is that Datetimes retrieved have the millisecond values truncated
      Datetime datetimeWithMs = potentiallyUnitializedDecimal instanceof Decimal
        ? Datetime.newInstance(((Decimal) potentiallyUnitializedDecimal).longValue())
        : ((Datetime) potentiallyUnitializedDecimal);
      return RollupFieldInitializer.Current.getApexCompliantDatetime(datetimeWithMs).getTime();
    }

    protected override Object calculateNewAggregateValue(Rollup.Op op, List<Object> excludedItems, SObjectType sObjectType) {
      Object aggregate = super.calculateNewAggregateValue(op, excludedItems, sObjectType);
      if (aggregate instanceof Datetime) {
        aggregate = ((Datetime) aggregate).getTime();
      }
      return aggregate;
    }
  }

  private inherited sharing class DateRollupCalculator extends DatetimeRollupCalculator {
    // for Date, it's not necessary to override the "getDecimalOrDefault" method in DatetimeRollupCalculator
    // because the conversion only happens in "getReturnValue"
    public DateRollupCalculator(
      Object priorVal,
      Rollup.Op op,
      SObjectField opFieldOnCalcItem,
      SObjectField opFieldOnLookupObject,
      Rollup__mdt metadata,
      String lookupRecordKey,
      SObjectField lookupKeyField
    ) {
      super(
        Datetime.newInstanceGmt((Date) priorVal, Time.newInstance(0, 0, 0, 0)),
        op,
        opFieldOnCalcItem,
        opFieldOnLookupObject,
        metadata,
        lookupRecordKey,
        lookupKeyField
      );
    }

    public override Object getReturnValue() {
      Object superReturnVal = super.getReturnValue();
      return superReturnVal == 0 ? null : ((Datetime) superReturnVal).dateGmt();
    }
  }

  private inherited sharing class TimeRollupCalculator extends DatetimeRollupCalculator {
    public TimeRollupCalculator(
      Object priorVal,
      Rollup.Op op,
      SObjectField opFieldOnCalcItem,
      SObjectField opFieldOnLookupObject,
      Rollup__mdt metadata,
      String lookupRecordKey,
      SObjectField lookupKeyField
    ) {
      super(
        Datetime.newInstanceGmt(RollupFieldInitializer.Current.defaultDateTime.dateGmt(), (Time) priorVal),
        op,
        opFieldOnCalcItem,
        opFieldOnLookupObject,
        metadata,
        lookupRecordKey,
        lookupKeyField
      );
    }

    public override Object getReturnValue() {
      Object returnValue = super.getReturnValue();
      if (returnValue instanceof Datetime) {
        returnValue = ((Datetime) returnValue).timeGmt();
      } else if (returnValue == 0) {
        returnValue = null;
      }
      return returnValue;
    }

    protected override Decimal getDecimalOrDefault(Object potentiallyUnitializedDecimal) {
      Datetime defaultDatetime;
      if (potentiallyUnitializedDecimal instanceof Time) {
        defaultDatetime = Datetime.newInstanceGmt(RollupFieldInitializer.Current.defaultDateTime.dateGmt(), (Time) potentiallyUnitializedDecimal);
      } else if (potentiallyUnitializedDecimal instanceof Decimal) {
        defaultDatetime = Datetime.newInstance(((Decimal) potentiallyUnitializedDecimal).longValue());
      }
      return (defaultDatetime != null ? defaultDatetime : RollupFieldInitializer.Current.defaultDateTime).getTime();
    }
  }

  private inherited sharing class CountRollupCalculator extends DecimalRollupCalculator {
    public CountRollupCalculator(
      Object priorVal,
      Rollup.Op op,
      SObjectfield opFieldOnCalcItem,
      SObjectField opFieldOnLookupObject,
      Rollup__mdt metadata,
      String lookupRecordKey,
      SObjectField lookupKeyField
    ) {
      super(priorVal, op, opFieldOnCalcItem, opFieldOnLookupObject, metadata, lookupRecordKey, lookupKeyField);
    }

    public override Object getReturnValue() {
      this.setReturnValue();
      // we shouldn't encourage negative counts. it's totally possible as a rollup is implemented and updates happen before
      // inserts or deletes, but it doesn't really make sense in the context of tracking
      Integer potentialReturnVal = ((Decimal) super.getReturnValue()).intValue();
      return potentialReturnVal < 0 ? 0.00 : potentialReturnVal;
    }

    protected override Decimal getNumericValue(SObject calcItem) {
      return calcItem.get(this.opFieldOnCalcItem) != null ? 1.00 : 0.00;
    }

    protected override Decimal getNumericChangedValue(SObject calcItem, Map<Id, SObject> oldCalcItems) {
      SObject oldCalcItem = oldCalcItems.containsKey(calcItem.Id) ? oldCalcItems.get(calcItem.Id) : calcItem;

      // for a reparenting, the item counts towards the new record on an update
      if (this.isReparented(calcItem, oldCalcItem)) {
        return 1.00;
      }

      Boolean matchesCurrent = this.eval?.matches(calcItem) == true;
      Boolean matchesPrior = this.eval?.matches(oldCalcItem) == true;

      // for updates, we have to decrement the count if the value has been cleared out
      Decimal retVal = 0.00;
      Object current = calcItem.get(this.opFieldOnCalcItem);
      Object prior = oldCalcItem.get(this.opFieldOnCalcItem);
      Object defaultVal = RollupFieldInitializer.Current.getDefaultValue(this.opFieldOnCalcItem);
      if (current == null && prior != null || matchesPrior && matchesCurrent == false) {
        retVal = -1.00;
      } else if (current != defaultVal && prior == defaultVal || matchesPrior == false && matchesCurrent) {
        retVal = 1.00;
      } else if (current == false && prior == true) {
        retVal = -1.00;
      }
      return retVal;
    }
  }

  private inherited sharing virtual class StringRollupCalculator extends RollupCalculator {
    protected String concatDelimiter = ', ';
    private String stringVal;

    private final Boolean isConcatDistinct;
    private final Set<Id> concatDistinctIds = new Set<Id>();

    public StringRollupCalculator(
      Object priorVal,
      Rollup.Op op,
      SObjectField opFieldOnCalcItem,
      SObjectField opFieldOnLookupObject,
      Rollup__mdt metadata,
      String lookupRecordKey,
      SObjectField lookupKeyField,
      String customConcatDelimiter
    ) {
      super(priorVal, op, opFieldOnCalcItem, opFieldOnLookupObject, metadata.FullRecalculationDefaultStringValue__c, metadata, lookupRecordKey, lookupKeyField);
      this.stringVal = (String) this.returnVal;
      if (String.isNotBlank(customConcatDelimiter)) {
        this.concatDelimiter = customConcatDelimiter + ' ';
      }
      this.isConcatDistinct = this.op.name().contains(Rollup.Op.CONCAT_DISTINCT.name());
    }

    protected override void setReturnValue() {
      if (this.op.name().contains(Rollup.Op.CONCAT.name())) {
        String trimmedDelimiter = this.concatDelimiter.trim();
        String possibleReturnValue = this.stringVal.normalizeSpace();
        while (possibleReturnValue.endsWith(trimmedDelimiter)) {
          possibleReturnValue = possibleReturnValue.substringBeforeLast(trimmedDelimiter).trim();
        }
        while (possibleReturnValue.startsWith(trimmedDelimiter)) {
          possibleReturnValue = possibleReturnValue.substringAfter(trimmedDelimiter).trim();
        }

        this.stringVal = (possibleReturnValue.startsWith(trimmedDelimiter)
            ? possibleReturnValue.substring(1, possibleReturnValue.length())
            : possibleReturnValue)
          .trim();
        this.sortAndConcat();
      }
      this.returnVal = this.stringVal;
    }

    protected override void handleShortCircuit(SObject calcItem) {
      switch on this.op {
        when UPDATE_MAX, UPDATE_MIN {
          String newVal = String.valueOf(calcItem.get(this.opFieldOnCalcItem));
          if (this.isTrueFor(newVal, this.stringVal)) {
            this.stringVal = newVal;
          }
        }
        when DELETE_CONCAT_DISTINCT {
          this.handleConcatDistinctDelete(calcItem);
        }
      }
    }

    public override void handleConcat(SObject calcItem) {
      String newVal = String.valueOf(calcItem.get(this.opFieldOnCalcItem));
      if (this.shouldConcat(newVal)) {
        this.stringVal += this.concatWithDelimiter(newVal);
      }
    }

    public override void handleUpdateConcat(SObject calcItem, Map<Id, SObject> oldCalcItems) {
      String newVal = String.valueOf(calcItem.get(this.opFieldOnCalcItem));
      SObject priorItem = oldCalcItems.get(calcItem.Id);
      String priorString = String.valueOf(priorItem != null ? priorItem.get(this.opFieldOnCalcItem) : newVal);
      if (this.eval?.matches(calcItem) == false && priorItem != null && this.eval?.matches(priorItem) == true) {
        this.handleDeleteConcat(calcItem);
      } else if (this.shouldConcat(newVal) || priorString != newVal) {
        this.stringVal = this.replaceWithDelimiter(this.stringVal, priorString, newVal);
      }
    }

    public override void handleDeleteConcat(SObject calcItem) {
      String existingVal = String.valueOf(calcItem.get(this.opFieldOnCalcItem));
      if (String.isBlank(existingVal)) {
        return;
      } else if (this.isConcatDistinct) {
        this.shouldShortCircuit = true;
        this.handleConcatDistinctDelete(calcItem);
      } else {
        this.stringVal = this.replaceWithDelimiter(this.stringVal, existingVal, '');
      }
    }

    public override void handleMin(SObject calcItem) {
      String newVal = String.valueOf(calcItem.get(this.opFieldOnCalcItem));
      if (this.isTrueFor(newVal, this.stringVal)) {
        this.stringVal = newVal;
      }
    }

    public override void handleMax(SObject calcItem) {
      this.handleMin(calcItem);
    }

    public override void handleUpdateMinOrMax(SObject calcItem, Map<Id, SObject> oldCalcItems) {
      String newVal = String.valueOf(calcItem.get(this.opFieldOnCalcItem));
      String priorString = String.valueOf((oldCalcItems.containsKey(calcItem.Id) ? oldCalcItems.get(calcItem.Id).get(this.opFieldOnCalcItem) : newVal));

      if (
        (this.op.name().contains(Rollup.Op.MAX.name()) && priorString == this.stringVal && newVal <= this.stringVal) ||
        (this.op.name().contains(Rollup.Op.MIN.name()) &&
        priorString == this.stringVal &&
        newVal >= this.stringVal)
      ) {
        this.shouldShortCircuit = true;
        Object potentialReturnValue = this.calculateNewAggregateValue(this.op, oldCalcItems.values(), calcItem.getSObjectType());
        this.stringVal = potentialReturnValue == null ? '' : String.valueOf(potentialReturnValue);
      } else if (this.isTrueFor(newVal, this.stringVal)) {
        this.stringVal = newVal;
      }
    }

    protected override Object calculateNewAggregateValue(Rollup.Op op, List<Object> objIds, SObjectType sObjectType) {
      this.stringVal = (String) super.performBaseCalculation(op, objIds, sObjectType);
      return this.stringVal;
    }

    protected virtual Boolean isTrueFor(String newVal, String priorVal) {
      Boolean isTrueFor = false;
      if (this.op.name().contains(Rollup.Op.MAX.name())) {
        isTrueFor = newVal > priorVal || String.isBlank(priorVal);
      } else if (this.op.name().contains(Rollup.Op.MIN.name())) {
        isTrueFor = newVal < priorVal || String.isBlank(priorVal);
      }
      return isTrueFor;
    }

    private void sortAndConcat() {
      List<String> values = this.stringVal.split(this.concatDelimiter);
      if (this.isConcatDistinct) {
        values = new List<String>(new Set<String>(values));
      }
      for (Integer index = values.size() - 1; index >= 0; index--) {
        if (String.isBlank(values[index])) {
          values.remove(index);
          continue;
        }
        if (this.metadata.SplitConcatDelimiterOnCalcItem__c == true) {
          List<String> splitValues = values[index].split(this.concatDelimiter);
          values.remove(index);
          for (String splitVal : splitValues) {
            if (values.contains(splitVal) == false) {
              values.add(splitVal);
            }
          }
        }
      }
      values.sort();
      this.stringVal = String.join(values, this.concatDelimiter);
    }

    private Boolean shouldConcat(String newVal) {
      Boolean shouldConcat = false;
      Boolean hasVal = String.isNotBlank(newVal);
      if (this.isConcatDistinct == false && hasVal) {
        shouldConcat = true;
      } else if (this.isConcatDistinct && hasVal) {
        List<String> existingVals = this.stringVal.split(this.concatDelimiter);
        Boolean matches = false;
        for (String existingVal : existingVals) {
          matches = existingVal == newVal;
          if (matches) {
            break;
          }
        }
        shouldConcat = matches == false;
      }

      return shouldConcat;
    }

    private String concatWithDelimiter(String newVal) {
      if (String.isBlank(this.stringVal) || this.stringVal.endsWith(this.concatDelimiter)) {
        return newVal + this.concatDelimiter;
      } else {
        return this.concatDelimiter + newVal + this.concatDelimiter;
      }
    }

    private String replaceWithDelimiter(String existingVal, String matchingVal, String replacementVal) {
      if (String.isNotBlank(matchingVal) && existingVal.contains(matchingVal)) {
        return existingVal.replace(matchingVal, replacementVal) + this.concatDelimiter;
      }
      return existingVal += this.concatDelimiter + replacementVal;
    }

    @SuppressWarnings('PMD.UnusedLocalVariable')
    private void handleConcatDistinctDelete(SObject calcItem) {
      // we do a replace first, in case this is a reparenting operation
      this.stringVal = this.replaceWithDelimiter(this.stringVal, (String) calcItem.get(this.opFieldOnCalcItem), '');
      this.concatDistinctIds.add(calcItem.Id);
      // we have to wait till it's the last iteration; this is what ensures that all of the deleted
      // items are accounted for in concatDistinctIds (for proper exclusion)
      if (this.isLastItem) {
        Set<Id> objIds = this.concatDistinctIds;
        String query = RollupQueryBuilder.Current.getQuery(
          calcItem.getSObjectType(),
          new List<String>{ this.opFieldOnCalcItem.getDescribe().getName() },
          'Id',
          '!=',
          this.lookupKeyQuery
        );
        List<SObject> relatedItems = Database.query(query);
        for (SObject relatedItem : relatedItems) {
          this.handleConcat(relatedItem);
        }
      }
    }
  }

  private inherited sharing class PicklistRollupCalculator extends StringRollupCalculator {
    private final RollupFieldInitializer.PicklistController picklistController;
    private final RollupFieldInitializer.PicklistController rollupFieldController;
    public PicklistRollupCalculator(
      Object priorVal,
      Rollup.Op op,
      SObjectfield opFieldOnCalcItem,
      SObjectField opFieldOnLookupObject,
      Rollup__mdt metadata,
      String lookupRecordKey,
      SObjectField lookupKeyField,
      String customConcatDelimiter
    ) {
      super(priorVal, op, opFieldOnCalcItem, opFieldOnLookupObject, metadata, lookupRecordKey, lookupKeyField, customConcatDelimiter);
      this.picklistController = new RollupFieldInitializer.PicklistController(opFieldOnCalcItem.getDescribe());
      this.rollupFieldController = new RollupFieldInitializer.PicklistController(opFieldOnLookupObject.getDescribe());
      if (this.rollupFieldController.isMultiSelectPicklist()) {
        this.concatDelimiter = ';';
      }
    }

    protected override Boolean isTrueFor(String newVal, String priorVal) {
      if (this.picklistController.isPicklist() == false) {
        return super.isTrueFor(newVal, priorVal);
      } else if (this.picklistController.isMultiSelectPicklist()) {
        // this operation isn't valid in SOQL, but at this point we wouldn't let a thing like that slow us down ...
        Integer newValRank = 0;
        Integer priorValRank = 0;
        for (String pickVal : newVal.split(';')) {
          newValRank += this.picklistController.getRank(pickVal, this.op);
        }
        for (String priorPickVal : priorVal.split(';')) {
          priorValRank += this.picklistController.getRank(priorPickVal, this.op);
        }
        return this.op.name().contains(Rollup.Op.MIN.name()) ? newValRank < priorValRank : newValRank > priorValRank;
      }
      return this.picklistController.isTrueFor(newVal, priorVal, this.op);
    }
  }

  private inherited sharing class AverageRollupCalculator extends RollupCalculator {
    public AverageRollupCalculator(
      Object priorVal,
      Rollup.Op op,
      SObjectField opFieldOnCalcItem,
      SObjectField opFieldOnLookupObject,
      Rollup__mdt metadata,
      String lookupRecordKey,
      SObjectField lookupKeyField
    ) {
      super(priorVal, op, opFieldOnCalcItem, opFieldOnLookupObject, metadata.FullRecalculationDefaultNumberValue__c, metadata, lookupRecordKey, lookupKeyField);
    }
    @SuppressWarnings('PMD.UnusedLocalVariable')
    public override void performRollup(List<SObject> calcItems, Map<Id, SObject> oldCalcItems) {
      List<SObject> applicableCalcItems = this.op == Rollup.Op.DELETE_AVERAGE ? new List<SObject>() : calcItems;
      applicableCalcItems = this.winnowItems(applicableCalcItems, oldCalcItems);
      Decimal oldSum;
      Decimal denominator = Decimal.valueOf(applicableCalcItems.size());
      if (this.isFullRecalc == false) {
        SObjectType sObjectType = this.getCalcItemType();
        List<SObject> objIds = calcItems;
        String query = RollupQueryBuilder.Current.getQuery(sObjectType, new List<String>{ 'Count()' }, 'Id', '!=', this.lookupKeyQuery);
        denominator += Database.countQuery(query);
        oldSum = (Decimal) this.calculateNewAggregateValue(Rollup.Op.SUM, calcItems, sObjectType);
      }

      if (oldSum == null) {
        oldSum = 0.00;
      }
      Decimal newSum = 0.00;
      for (SObject calcItem : applicableCalcItems) {
        Object potentialDecimal = calcItem.get(this.opFieldOnCalcItem);
        newSum += potentialDecimal == null ? 0.00 : (Decimal) potentialDecimal;
      }

      Decimal average = null;
      // We can't do the division if the denominator is 0
      if (denominator != 0) {
        Decimal numerator = oldSum + newSum;
        average = numerator / denominator;
      }
      this.returnVal = average;
    }
  }

  private inherited sharing class FirstLastRollupCalculator extends RollupCalculator {
    public FirstLastRollupCalculator(
      Object priorVal,
      Rollup.Op op,
      SObjectField opFieldOnCalcItem,
      SObjectField opFieldOnLookupObject,
      Rollup__mdt metadata,
      String lookupRecordKey,
      SObjectField lookupKeyField
    ) {
      super(
        priorVal,
        op,
        opFieldOnCalcItem,
        opFieldOnLookupObject,
        // first/last could possibly use either default value
        // we also have to cast to Object to avoid the compilation error:
        // "Incompatible types in ternary operator: String, Decimal"
        (metadata.FullRecalculationDefaultNumberValue__c != null
          ? (Object) metadata.FullRecalculationDefaultNumberValue__c
          : (Object) metadata.FullRecalculationDefaultStringValue__c),
        getFirstLastMetadata(metadata),
        lookupRecordKey,
        lookupKeyField
      );
      SObjectType calcItemSObjectType = ((SObject) Type.forName(this.metadata.CalcItem__c).newInstance()).getSObjectType();
      Map<String, SObjectField> fieldMap = calcItemSObjectType.getDescribe().fields.getMap();
      for (RollupOrderBy__mdt orderByInfo : this.metadata.RollupOrderBys__r) {
        SObjectField orderByFirstLastField = fieldMap.get(orderByInfo.FieldName__c);
        this.isMultiCurrencyRollup =
          this.isMultiCurrencyRollup || UserInfo.isMultiCurrencyOrganization() && orderByFirstLastField?.getDescribe().getType() == DisplayType.CURRENCY;
      }
    }

    @SuppressWarnings('PMD.UnusedLocalVariable')
    public override void performRollup(List<SObject> calcItems, Map<Id, SObject> oldCalcItems) {
      if (this.isFullRecalc == false) {
        SObjectType sObjectType = this.getCalcItemType();
        Set<String> queryFields = new Set<String>{ String.valueOf(this.opFieldOnCalcItem), this.metadata.LookupFieldOnCalcItem__c };
        for (RollupOrderBy__mdt orderByInfo : this.metadata.RollupOrderBys__r) {
          queryFields.add(orderByInfo.FieldName__c);
        }
        if (String.isNotBlank(this.metadata.CalcItemWhereClause__c)) {
          queryFields.addAll(RollupEvaluator.getWhereEval(this.metadata.CalcItemWhereClause__c, sObjectType).getQueryFields());
        }
        // a full-recalc is always necessary because we don't retain the information about the order by field
        String queryString = RollupQueryBuilder.Current.getQuery(sObjectType, new List<String>(queryFields), 'Id', '!=', this.lookupKeyQuery);

        // objIds is used as a bind variable in the resulting queryString
        List<SObject> objIds = calcItems;
        // we have to exclude the current items on delete, otherwise they'll be incorrectly considered
        List<SObject> additionalItems = Database.query(queryString);
        if (this.op.name().contains('DELETE')) {
          calcItems = additionalItems;
        } else {
          calcItems.addAll(additionalItems);
        }
      }

      calcItems = this.winnowItems(calcItems, oldCalcItems);

      new RollupFirstLastSorter(this.op, this.metadata.RollupOrderBys__r).sort(calcItems);
      this.returnVal = calcItems.isEmpty() ? null : calcItems[0].get(this.opFieldOnCalcItem);
    }
  }

  private static Rollup__mdt getFirstLastMetadata(Rollup__mdt metadata) {
    if (metadata.RollupOrderBys__r.isEmpty()) {
      String fieldName = String.isNotBlank(metadata.OrderByFirstLast__c) ? metadata.OrderByFirstLast__c : metadata.RollupFieldOnCalcItem__c;
      return Rollup.appendOrderByMetadata(metadata, new List<RollupOrderBy__mdt>{ new RollupOrderBy__mdt(Ranking__c = 0, FieldName__c = fieldName) });
    }
    return metadata;
  }
}
